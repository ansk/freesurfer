#! /bin/tcsh -f

#
# trac-preproc
#
# Tractography pre-processing for a single subject
#
# Original Author: Anastasia Yendiki
#
# Copyright Â© 2011 The General Hospital Corporation (Boston, MA) "MGH"
#
# Terms and conditions for use, reproduction, distribution and contribution
# are found in the 'FreeSurfer Software License Agreement' contained
# in the file 'LICENSE' found in the FreeSurfer distribution, and here:
#
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
#
# Reporting: freesurfer@nmr.mgh.harvard.edu
#
#

umask 002

set VERSION = 'trac-preproc @FS_VERSION@';
set ProgName = `basename $0`
set inputargs = ($argv)

#------------ Set default options -----------------------------------------#

set PrintHelp = 0	# Print help and exit

set debug = 0		# Generate more output

set DoTime = 0		# Time main commands
set fs_time = ()

set rcfile = ()		# Name of input run command file
set LF = ()		# Name of log file
set CF = ()		# Name of command file

set DoIsRunning = 1	# Create a lock file while processing continues

set RunIt = 1		# If 0, do everything but run commands (for debugging)

#------------ Parse input arguments ---------------------------------------#

if ($#argv == 0) goto usage_exit

set n = `echo $argv | egrep -e -help | wc -l`
if ($n != 0) then
  set PrintHelp = 1
  goto usage_exit
endif

set n = `echo $argv | egrep -e -version | wc -l`
if ($n != 0) then
  echo $VERSION
  exit 0
endif

source $FREESURFER_HOME/sources.csh

goto parse_args
parse_args_return:
goto check_params
check_params_return:

#------------ Read configuration file -------------------------------------#

source $rcfile

if ($DoTime) then
  fs_time ls >& /dev/null
  if (! $status) set fs_time = fs_time
endif

printf '\n\n' >> $LF
echo "New invocation of $ProgName"  >> $LF
printf '\n\n' >> $LF
whoami >> $LF
hostname >> $LF
uname -a >> $LF
limit >> $LF
if (-e /usr/bin/free) then
  echo "" >> $LF
  /usr/bin/free >> $LF
  echo "" >> $LF
endif
if ("`uname -s`" == "Darwin") then
  echo "" >> $LF
  /usr/bin/top -l 1 | grep PhysMem >> $LF
  echo "" >> $LF
endif

#---------- Is this a longitudinal base template? -----------------------#

set dobase = 0

if ($?tplist) then
  if ($#tplist > 0) set dobase = 1
endif

#---------- Create output directories -----------------------------------#

set dtdir = $dtroot/$subj
set fsdir = $SUBJECTS_DIR/$subj
set dwidir = $dtdir/dmri
set xfmdir = $dwidir/xfms
set labdir = $dtdir/dlabel
set touchdir = $dtdir/touch

mkdir -p $dwidir $xfmdir $labdir

#---------- Handle run status files -------------------------------------#

# Delete the error file. This is created when error_exit is run.
set ErrorFile = $dtdir/scripts/trac-all.error
rm -f $ErrorFile

# Delete the done file. This is created when the program exits normally.
set DoneFile = $dtdir/scripts/$ProgName.done
rm -f $DoneFile

if ($DoIsRunning) then
  set IsRunningFile = $dtdir/scripts/IsRunning.trac

  if (-e $IsRunningFile) then
    echo ""
    echo "ERROR: it appears that an analysis is already running"
    echo "for $subj based on the presence of $IsRunningFile. It could"
    echo "also be that an analysis was running at one point but"
    echo "died in an unexpected way. If it is the case that there"
    echo "is a process running, you can kill it and start over or"
    echo "just let it run. If the process has died, you should type:"
    echo ""
    echo "rm $IsRunningFile"
    echo ""
    echo "and re-run. Or you can add -no-isrunning to the trac-all"
    echo "command-line. The contents of this file are:"
    echo "----------------------------------------------------------"
    cat  $IsRunningFile
    echo "----------------------------------------------------------"
    exit 1
  endif

  echo "------------------------------"	>  $IsRunningFile 
  echo "SUBJECT $subj"			>> $IsRunningFile 
  echo "DATE `date`"			>> $IsRunningFile 
  echo "USER `whoami`"			>> $IsRunningFile 
  echo "HOST `hostname`"		>> $IsRunningFile 
  echo "PROCESSID $$"			>> $IsRunningFile 
  echo "PROCESSOR `uname -m`"		>> $IsRunningFile 
  echo "OS `uname -s`"			>> $IsRunningFile 
  uname -a				>> $IsRunningFile 
  echo "PROGRAM $ProgName"		>> $IsRunningFile 
  echo $VERSION				>> $IsRunningFile 
else
  set IsRunningFile = ()
endif

# Put a copy of myself (this script) in the scripts dir
cp $0 $dtdir/scripts/$ProgName.local-copy

if (! $RunIt) then
  echo "INFO: -dontrun flag is in effect so subsequent commands" |& tee -a $LF
  echo "may not have accurate arguments!" |& tee -a $LF
endif

echo "#-------------------------------------" |& tee -a $LF
echo "$0 $argv" |& tee -a $LF |& tee -a $CF

#------------ Image corrections -------------------------------------------#

if ($docorr && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Image corrections `date`" |& tee -a $LF

  mkdir -p $labdir/diff

  # Convert DWIs from DICOM or other format
  set nrun = $#dcmfile			# Number of input DWI runs

  rm -f $dwidir/dcminfo.dat
 
  @ irun = 1
  while ($irun <= $nrun)		# For each input DWI run
    set dwibase = $dwidir/dwi_orig.$irun

    set infile = $dcmfile[$irun]
    if ($#dcmroot > 0) set infile = $dcmroot/$infile

    set cmd = (rm -f $dwibase.bvals $dwibase.bvecs)
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mri_convert --bvec-voxel $infile $dwibase.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    if (-e $dwibase.voxel_space.bvecs) then
      set cmd = (mv -f $dwibase.voxel_space.bvecs $dwibase.bvecs)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    if (`mri_info --format $infile` =~ *dicom*) then
      set cmd = (mri_probedicom --i $infile)
      echo "$cmd >> $dwidir/dcminfo.dat" |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        ($cmd >> $dwidir/dcminfo.dat) >>& $LF
        if ($status) goto error_exit
      endif
    endif

    @ irun = $irun + 1
  end					# For each input DWI run

  # Get gradient and b-value tables (if provided by user)
  @ irun = 1
  while ($irun <= $nrun)		# For each input DWI run
    set dwibase = $dwidir/dwi_orig.$irun

    if ($#bvecfile) then
      if ($#bvecfile == 1) then
        set infile = $bvecfile
      else
        set infile = $bvecfile[$irun]
      endif
      if ($#dcmroot > 0) set infile = $dcmroot/$infile

      if ($infile != $dwibase.bvecs) then
        if ($RunIt) then
          tr -d '\r' < $infile > $dwibase.bvecs
          if ($status) goto error_exit
        endif
      endif
    endif

    if ($#bvalfile) then
      if ($#bvalfile == 1) then
        set infile = $bvalfile
      else
        set infile = $bvalfile[$irun]
      endif
      if ($#dcmroot > 0) set infile = $dcmroot/$infile

      if ($infile != $dwibase.bvals) then
        if ($RunIt) then
          tr -d '\r' < $infile > $dwibase.bvals
          if ($status) goto error_exit
        endif
      endif
    endif

    @ irun = $irun + 1
  end					# For each input DWI run

  # Assume that DWI DICOMs without gradient and b-value tables are b=0 only
  set novecs = 1

  @ irun = 1
  while ($irun <= $nrun)		# For each input DWI run
    set dwibase = $dwidir/dwi_orig.$irun

    if (-e $dwibase.bvecs && -e $dwibase.bvals) then
      set novecs = 0
    else
      if (! -e $dwibase.bvecs) \
        echo "WARN: No gradient table found for $dwibase.nii.gz"

      if (! -e $dwibase.bvals) \
        echo "WARN: No b-value table found for $dwibase.nii.gz"

      echo "WARN: Assuming that this is a b=0 scan only"

      rm -f $dwibase.bvecs $dwibase.bvals

      set nvol = `mri_info --nframes $dwibase.nii.gz`

      @ ivol = 1
      while ($ivol <= $nvol)
        echo 0 0 0 >> $dwibase.bvecs
        echo 0     >> $dwibase.bvals

        @ ivol = $ivol + 1
      end
    endif

    @ irun = $irun + 1
  end					# For each input DWI run

  if ($novecs) then
    echo "ERROR: No gradient tables or b-value tables found"
    goto error_exit
  endif

  @ irun = 1
  while ($irun <= $nrun)		# For each input DWI run
    set dwibase    = $dwidir/dwi_orig.$irun
    set dwibaseLAS = $dwidir/dwi_orig_las.$irun

    # Check if there is the same number of b-values and gradient vectors
    set nvec = `wc -w $dwibase.bvecs | awk '{print $1}'`
    set nvec = `echo "$nvec/3" | bc -l`
    set nvec = `printf '%g' $nvec`

    set nval = `wc -w $dwibase.bvals | awk '{print $1}'`

    if ($nval != $nvec) then
      echo "ERROR: Found $nval b-values but $nvec gradient vectors for $dwibase"
      goto error_exit
    endif

    # Check if gradient vectors are arranged in 3 rows or 3 columns
    if (`awk 'NR==1' $dwibase.bvecs | wc -w` == 3) then
      set vectype = cols
    else if (`awk '{print $1}' $dwibase.bvecs | wc -w` == 3) then
      set vectype = rows
    else
      echo "ERROR: Gradient vectors must be 3 rows or 3 columns of coordinates"
      goto error_exit
    endif

    # Convert gradient vectors to 3-column format
    if ($vectype == rows) then
      set xx = `awk 'NR==1' $dwibase.bvecs`
      set yy = `awk 'NR==2' $dwibase.bvecs`
      set zz = `awk 'NR==3' $dwibase.bvecs`
    else
      set xx = `awk '{print $1}' $dwibase.bvecs`
      set yy = `awk '{print $2}' $dwibase.bvecs`
      set zz = `awk '{print $3}' $dwibase.bvecs`
    endif

    set blist = `cat $dwibase.bvals`

    set cmd = (rm -f $dwibase.bvals.tmp $dwibase.bvecs.tmp)
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    @ k = 1
    while ($k <= $#blist)
      echo $blist[$k] >> $dwibase.bvals.tmp
      echo $xx[$k] $yy[$k] $zz[$k] >> $dwibase.bvecs.tmp
      @ k = $k + 1
    end

    set cmd = (mv -f $dwibase.bvecs.tmp $dwibase.bvecs)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mv -f $dwibase.bvals.tmp $dwibase.bvals)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Change orientation to LAS
    set cmd = (orientLAS $dwibase.nii.gz $dwibaseLAS.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    @ irun = $irun + 1
  end					# For each input DWI run

  if ($doeddy > 1 || $dob0 > 1) then    # Set up acquisition parameter file
    rm -f $dwidir/acqp.txt

    @ irun = 1
    while ($irun <= $nrun)		# For each input DWI run
      if ($#pedir == 1) then
        set pe = $pedir
      else
        set pe = $pedir[$irun]
      endif

      if ($#echospacing == 1) then
        set esp = $echospacing
      else
        set esp = $echospacing[$irun]
      endif
      
      if ($#epifactor == 1) then
        set epif = $epifactor
      else
        set epif = $epifactor[$irun]
      endif
      
      # Direction of increasing phase-encode lines (assuming LAS orientation)
      if ($pe == RL) then
        set pexyz = (1 0 0)
      else if ($pe == LR) then
        set pexyz = (-1 0 0)
      else if ($pe == PA) then
        set pexyz = (0 1 0)
      else if ($pe == AP) then
        set pexyz = (0 -1 0)
      else if ($pe == IS) then
        set pexyz = (0 0 1)
      else if ($pe == SI) then
        set pexyz = (0 0 -1)
      endif

      # Dwell time
      set dwell = `echo "$esp * .001 * ($epif - 1)" | bc -l`

      echo $pexyz $dwell >> $dwidir/acqp.txt

      @ irun = $irun + 1
    end					# For each input DWI run
  endif

  if ($dob0 > 1) then			# B0 inhomogeneities: with topup
    if ( `printf '%s\n' $pedir       | sort --unique | wc -w` < 2 && \
         `printf '%s\n' $echospacing | sort --unique | wc -w` < 2 ) then
      echo "ERROR: All input scans have the same PE direction and echo-spacing"
      echo "ERROR: Cannot correct B0 distortions with topup"
      goto error_exit
    endif

    # Extract first b=0 volume from each run
    set flist = ()

    @ irun = 1
    while ($irun <= $nrun)		# For each input DWI run
      set dwibase = $dwidir/dwi_orig_las.$irun
      set lowbase = $dwidir/lowb_orig_las.$irun

      set bmin = `grep -v ^$ $dwibase.bvals | sort --numeric-sort | head -n 1`
      set lowblist = `cat $dwibase.bvals \
                      | awk -v bmin=$bmin '{if ($1 == bmin) print NR-1}'`

      set cmd = mri_convert
      set cmd = ($cmd --frame $lowblist[1])
      set cmd = ($cmd $dwibase.nii.gz)
      set cmd = ($cmd $lowbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set flist = ($flist $lowbase.nii.gz)

      @ irun = $irun + 1
    end					# For each input DWI run

    # Concatenate first b=0 volume from all runs
    set cmd = mri_concat
    set cmd = ($cmd --i $flist)
    set cmd = ($cmd --o $dwidir/lowb_orig_las.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Estimate off-resonance field
    set cmd = topup
    set cmd = ($cmd --imain=$dwidir/lowb_orig_las.nii.gz)
    set cmd = ($cmd --datain=$dwidir/acqp.txt)
    set cmd = ($cmd --config=b02b0.cnf)
    set cmd = ($cmd --out=$dwidir/topup)
    set cmd = ($cmd --iout=$dwidir/lowb_topup.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    if (! $doeddy) then			# Apply correction now
      @ irun = 1
      while ($irun <= $nrun)		# For each input DWI run
        set dwibase = $dwidir/dwi_orig_las.$irun
        set dwibasetop = $dwidir/dwi.$irun

        set cmd = applytopup
        set cmd = ($cmd --imain=$dwibase.nii.gz)
        set cmd = ($cmd --inindex=$irun)
        set cmd = ($cmd --datain=$dwidir/acqp.txt)
        set cmd = ($cmd --topup=$dwidir/topup)
        set cmd = ($cmd --method=jac)
        set cmd = ($cmd --out=$dwibasetop.nii.gz)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif

        # Copy gradient table
        set cmd = (cp -p $dwibase.bvecs $dwibasetop.bvecs)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif

        # Copy b-value table
        set cmd = (cp -p $dwibase.bvals $dwibasetop.bvals)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif

        @ irun = $irun + 1
      end				# For each input DWI run

      set dwibase = $dwidir/dwi
    else				# Will apply correction later
      set dwibase = $dwidir/dwi_orig_las
    endif
  else					# No topup, only combine runs
    set dwibase = $dwidir/dwi_orig_las
  endif

  # Combine all DWI runs
  if ($nrun == 1) then			# Have one run only
    set cmd = (mv -f $dwibase.1.nii.gz $dwibase.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mv -f $dwibase.1.bvecs $dwibase.bvecs)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mv -f $dwibase.1.bvals $dwibase.bvals)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  else					# Have multiple runs
    set flist_dwi = ()
    set flist_vec = ()
    set flist_val = ()

    @ irun = 1
    while ($irun <= $nrun)		# For each input DWI run
      set flist_dwi = ($flist_dwi $dwibase.$irun.nii.gz)
      set flist_vec = ($flist_vec $dwibase.$irun.bvecs)
      set flist_val = ($flist_val $dwibase.$irun.bvals)

      @ irun = $irun + 1
    end					# For each input DWI run

    set cmd = mri_concat
    set cmd = ($cmd --i $flist_dwi)
    set cmd = ($cmd --o $dwibase.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (cat $flist_vec)
    echo "$cmd > $dwibase.bvecs" |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      ($cmd > $dwibase.bvecs) >>& $LF
      if ($status) goto error_exit
    endif

    set cmd = (cat $flist_val)
    echo "$cmd > $dwibase.bvals" |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      ($cmd > $dwibase.bvals) >>& $LF
      if ($status) goto error_exit
    endif
  endif

  if ($doeddy > 1) then			# Eddy currents: with eddy
    set dwibase = $dwidir/dwi_orig_las

    # Create a temporary brain mask
    if ($dob0 > 1) then			# Have b=0 images unwarped by topup
      set lowbase = $dwidir/lowb_topup

      set cmd = mri_concat
      set cmd = ($cmd --i $lowbase.nii.gz)
      set cmd = ($cmd --mean)
      set cmd = ($cmd --o $lowbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    else				# Use first b=0 image
      set lowbase = $dwidir/lowb_orig_las

      set bmin = `grep -v ^$ $dwibase.bvals | sort --numeric-sort | head -n 1`
      set lowblist = `cat $dwibase.bvals \
                      | awk -v bmin=$bmin '{if ($1 == bmin) print NR-1}'`

      set cmd = mri_convert
      set cmd = ($cmd --frame $lowblist[1])
      set cmd = ($cmd $dwibase.nii.gz)
      set cmd = ($cmd $lowbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    set cmd = bet
    set cmd = ($cmd $lowbase.nii.gz)
    set cmd = ($cmd ${lowbase}_brain.nii.gz)
    set cmd = ($cmd -m -f $thrbet)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Create volume index file
    set indlist = ()

    @ irun = 1
    while ($irun <= $nrun)		# For each input DWI run
      set indlist = ($indlist \
        `awk -v irun=$irun '{printf irun" "}' $dwibase.$irun.bvals`)

      @ irun = $irun + 1
    end					# For each input DWI run

    echo $indlist > $dwidir/index.txt

    # Correction
    set cmd = eddy_openmp
    set cmd = ($cmd --imain=$dwidir/dwi_orig_las.nii.gz)
    set cmd = ($cmd --mask=${lowbase}_brain_mask.nii.gz)
    set cmd = ($cmd --bvecs=$dwidir/dwi_orig_las.bvecs)
    set cmd = ($cmd --bvals=$dwidir/dwi_orig_las.bvals)
    set cmd = ($cmd --acqp=$dwidir/acqp.txt)
    set cmd = ($cmd --index=$dwidir/index.txt)
    if ($dob0 > 1) then			# Use previously run topup output
      set cmd = ($cmd --topup=$dwidir/topup)
    endif
    if ($doeddy > 2) then		# Perform outlier replacement
      set cmd = ($cmd --repol)
    endif
    set cmd = ($cmd --out=$dwidir/dwi)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  else if ($doeddy == 1) then		# Eddy currents: with eddy_correct
    rm -f $dwidir/dwi.ecclog

    set cmd = eddy_correct
    set cmd = ($cmd $dwidir/dwi_orig_las.nii.gz $dwidir/dwi.nii.gz 0)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    if ($dob0 > 1) then			# Apply unwarping from topup
      set cmd = (mv -f $dwidir/dwi.nii.gz $dwidir/dwi_eddy.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set fstart = 0
      set flist = ()

      @ irun = 1
      while ($irun <= $nrun)		# For each input DWI run
        set nframe = `wc -w $dwidir/dwi_orig.$irun.bvals | awk '{print $1}'`
        set fend = `echo "$fstart + $nframe" | bc`

        set cmd = mri_convert
        set cmd = ($cmd --fsubsample $fstart 1 $fend)
        set cmd = ($cmd $dwidir/dwi_eddy.nii.gz)
        set cmd = ($cmd $dwidir/dwi.$irun.nii.gz)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif

        set cmd = applytopup
        set cmd = ($cmd --imain=$dwidir/dwi.$irun.nii.gz)
        set cmd = ($cmd --inindex=$irun)
        set cmd = ($cmd --datain=$dwidir/acqp.txt)
        set cmd = ($cmd --topup=$dwidir/topup)
        set cmd = ($cmd --method=jac)
        set cmd = ($cmd --out=$dwidir/dwi.$irun.nii.gz)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif

        set fstart = $fend
        set flist = ($flist $dwidir/dwi.$irun.nii.gz)

        @ irun = $irun + 1
      end				# For each input DWI run

      # Concatenate them back together
      set cmd = mri_concat
      set cmd = ($cmd --i $flist)
      set cmd = ($cmd --o $dwidir/dwi.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif
  else if (! $doeddy && $dob0 < 2) then		# No eddy-current corrections
    set cmd = (mv -f $dwidir/dwi_orig_las.nii.gz $dwidir/dwi.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mv -f $dwidir/dwi_orig_las.bvecs $dwidir/dwi.bvecs)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = (mv -f $dwidir/dwi_orig_las.bvals $dwidir/dwi.bvals)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif

  if ($doeddy) then
    # Apply rotation from eddy-current correction to gradient vectors
    if ($dorotbvecs) then
      set cmd = xfmrot
      if ($doeddy > 1) then		# From eddy
        set cmd = ($cmd $dwidir/dwi.eddy_parameters)
      else if ($doeddy == 1) then	# From eddy_correct
        set cmd = ($cmd $dwidir/dwi.ecclog)
      endif
      set cmd = ($cmd $dwidir/dwi_orig_las.bvecs)
      set cmd = ($cmd $dwidir/dwi.bvecs)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    else
      set cmd = (cp -p $dwidir/dwi_orig_las.bvecs $dwidir/dwi.bvecs)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    # Copy b-value table
    set cmd = (cp -p $dwidir/dwi_orig_las.bvals $dwidir/dwi.bvals)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif

  if ($dob0 == 1) then			# B0 inhomogeneities: with field map
    if ($doeddy) then
      set cmd = (mv -f $dwidir/dwi.nii.gz $dwidir/dwi_eddy.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set indwi = dwi_eddy
    else
      set indwi = dwi_orig_las
    endif

    set cmd = (mri_convert --frame 0 $dwidir/$indwi.nii.gz $dwidir/lowb.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Do I have one field map for all DWI runs or a different one for each run?
    if (`printf '%s\n' $b0mfile | sort --unique | wc -l` == 1) then
      set b0mfile = $b0mfile[1]
      set b0pfile = $b0pfile[1]
    endif

    set nmap = $#b0mfile

    set fstart = 0
    set fend = 0
    set flist = ()

    @ imap = 1
    while ($imap <= $nmap)		# For each input field map
      if ($nmap == 1) then
        set magbase = $dwidir/b0mag
        set phabase = $dwidir/b0pha
        set infbase = $dwidir/b0info
        set dwibase = $dwidir/$indwi
        set outbase = $dwidir/dwi
      else
        set magbase = $dwidir/b0mag.$imap
        set phabase = $dwidir/b0pha.$imap
        set infbase = $dwidir/b0info.$imap
        set dwibase = $dwidir/dwi.$imap
        set outbase = $dwidir/dwi.$imap

        set flist = ($flist $outbase.nii.gz)

        set nframe = `wc -w $dwidir/dwi_orig.$imap.bvals | awk '{print $1}'`
        set fstart = $fend
        set fend = `echo "$fstart + $nframe" | bc`

        set cmd = mri_convert
        set cmd = ($cmd --fsubsample $fstart 1 $fend)
        set cmd = ($cmd $dwidir/$indwi.nii.gz)
        set cmd = ($cmd $dwibase.nii.gz)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      endif

      # Magnitude maps
      set infile = $b0mfile[$imap]
      if ($#dcmroot > 0) set infile = $dcmroot/$infile

      set cmd = (mri_convert $infile $magbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set cmd = (orientLAS $magbase.nii.gz $magbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      # Phase maps
      set infile = $b0pfile[$imap]
      if ($#dcmroot > 0) set infile = $dcmroot/$infile

      set cmd = (mri_convert $infile $phabase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set cmd = (orientLAS $phabase.nii.gz $phabase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      # Will use info from DICOM header to find dTE
      if (`mri_info --format $infile` =~ *dicom*) then
        set cmd = (mri_probedicom --i $infile)
        echo "$cmd > $infbase.dat" |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          ($cmd > $infbase.dat) >>& $LF
          if ($status) goto error_exit
        endif

        set TE = `grep alTE $infbase.dat | awk '{print $3}'`
        set dTE = `echo "($TE[2] - $TE[1])/1000" | bc -l`
      endif

      if ($#dTE) then
        echo "ERROR: Need dTE for field map $infile"
        goto error_exit
      endif

      if ($#echospacing == 1) then
        set esp = $echospacing
      else
        set esp = $echospacing[$imap]
      endif
      
      set cmd = epidewarp.fsl
      set cmd = ($cmd --mag $magbase.nii.gz)
      if (`mri_info --nframes $phabase.nii.gz` == 2) then
        set cmd = ($cmd --ph $phabase.nii.gz)	# Two phase maps
      else if (`mri_info --nframes $phabase.nii.gz` == 1) then
        set cmd = ($cmd --dph $phabase.nii.gz)	# Phase difference map
      else
        echo "ERROR: Unrecognized format of phase map $phabase.nii.gz"
        goto error_exit
      endif
      set cmd = ($cmd --exf $dwidir/lowb.nii.gz)
      set cmd = ($cmd --epi $dwibase.nii.gz)
      set cmd = ($cmd --tediff $dTE --esp $esp)
      set cmd = ($cmd --vsm $dwidir/vsm.nii.gz)
      set cmd = ($cmd --epidw $outbase.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      @ imap = $imap + 1
    end

    if ($nmap > 1) then
      cmd = mri_concat
      cmd = ($cmd --i $flist)
      cmd = ($cmd --o $dwidir/dwi.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif
  endif

### TODO: TOPUP OUTPUT ONLY, NOT EDDY #
  # In case FSL tools have wiped out the xform from the NIfTI header
  set cmd = mri_convert
  if (-e $dwidir/dwi_orig_las.nii.gz) then
    set cmd = ($cmd --in_like $dwidir/dwi_orig_las.nii.gz)
  else
    set cmd = ($cmd --in_like $dwidir/dwi_orig_las.1.nii.gz)
  endif
  set cmd = ($cmd $dwidir/dwi.nii.gz $dwidir/dwi.nii.gz)
  if ($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif
#######################################

  # In case I have discarded frames before, clean up
  set cmd = (rm -f $dwidir/dwi.full.nii.gz)
  set cmd = ($cmd  $dwidir/dwi.bvecs.full $dwidir/dwi.bvals.full)
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  # Create symbolic links to files with the names that bedpostx expects
  set cmd = (ln -sf $dwidir/dwi.nii.gz $dwidir/data.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

### TODO: RENAMED THESE ###############
  set cmd = (ln -sf $dwidir/dwi.bvecs $dwidir/bvecs)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  set cmd = (ln -sf $dwidir/dwi.bvals $dwidir/bvals)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif
######################################

  # Make diffusion brain mask
  if ($#nb0 > 0) then
    set lowblist = ()
    @ k = 0
    while ($k < $nb0)
      set lowblist = ($lowblist $k)
      @ k = $k + 1
    end
  else
    set bmin = `grep -v ^$ $dwidir/dwi.bvals \
                | sort --numeric-sort | head -n 1`
    set lowblist = `cat $dwidir/dwi.bvals \
                    | awk -v bmin=$bmin '{if ($1 == bmin) print NR-1}'`
  endif

  if (! $#lowblist) then
    echo "ERROR: Cannot detect low-b volumes"
    goto error_exit
  endif

  set cmd = mri_convert
  set cmd = ($cmd --frame $lowblist)
  set cmd = ($cmd $dwidir/dwi.nii.gz)
  set cmd = ($cmd $dwidir/lowb.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  set cmd = mri_concat
  set cmd = ($cmd --i $dwidir/lowb.nii.gz)
  set cmd = ($cmd --mean)
  set cmd = ($cmd --o $dwidir/lowb.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  set cmd = bet
  set cmd = ($cmd $dwidir/lowb.nii.gz)
  set cmd = ($cmd $dwidir/lowb_brain.nii.gz)
  set cmd = ($cmd -m -f $thrbet)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  set cmd = (mv -f $dwidir/lowb_brain_mask.nii.gz $labdir/diff)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  # If using a subset of b-values
  if ($#bmax) then
    set cmd = dmri_bset
    set cmd = ($cmd --in   $dwidir/dwi.nii.gz)
    set cmd = ($cmd --bmax $bmax)
    set cmd = ($cmd --out  $dwidir/dwi.bmax$bmax.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif

  if ($#bshell) then
    set cmd = dmri_bset
    set cmd = ($cmd --in  $dwidir/dwi.nii.gz)
    set cmd = ($cmd `printf '--b %s ' $bshell`)
    set cmd = ($cmd --out $dwidir/dwi.`printf 'b%s.' $bshell`nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif
endif

if ($docorr && $dobase) then
  echo "ERROR: Image correction step not available for base template"
  goto error_exit
endif

#------------ Image quality assessment ------------------------------------#

if ($doqa && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Image quality assessment `date`" |& tee -a $LF

  # Find an intensity value that is representative of WM in low-b image
  set imthr = `fslstats $dwidir/lowb.nii.gz \
                     -k $labdir/diff/lowb_brain_mask.nii.gz -p 20`

  set parfile = ()
  if ($doeddy > 1) then
    set parfile = $dwidir/dwi.eddy_parameters
    if (! -e $parfile) then
      echo "ERROR: Missing eddy output; need to run trac-all -corr"
      goto error_exit
    endif
  else if ($doeddy == 1) then
    set parfile = $dwidir/dwi.ecclog
    if (! -e $parfile) then
      echo "ERROR: Missing eddy_correct output; need to run trac-all -corr"
      goto error_exit
    endif
  endif

  set runs = `printf '%s\n' $dcmfile | awk '{print NR}'`
  set dwiruns = `printf "$dwidir/dwi_orig.%d.nii.gz " $runs`
  set bvalruns = `printf "$dwidir/dwi_orig.%d.bvals " $runs`

  set cmd = $trcdir/dmri_motion
  if ($#parfile) then
    set cmd = ($cmd --mat $parfile)
  endif
  set cmd = ($cmd --dwi   $dwiruns)
  set cmd = ($cmd --bval  $bvalruns)
  set cmd = ($cmd --T     $imthr)
  set cmd = ($cmd --out   $dwidir/dwi_motion.txt)
  set cmd = ($cmd --outf  $dwidir/dwi_motion_byvol.txt)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  if (-e $dwidir/keepframes.txt) then		# Remove bad frames
    set keepframes = `cat $dwidir/keepframes.txt \
                      | sort --numeric-sort --unique`

    # Remove frames from DWI series
    # If I have done this before, be careful not to overwrite the full set
    if (! -e $dwidir/dwi.full.nii.gz) then
      set cmd = (mv -f $dwidir/dwi.nii.gz $dwidir/dwi.full.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    set cmd = mri_convert
    set cmd = ($cmd --frame $keepframes)
    set cmd = ($cmd $dwidir/dwi.full.nii.gz)
    set cmd = ($cmd $dwidir/dwi.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Remove the respective gradient vectors and b-values
    # If I have done this before, be careful not to overwrite the full set
    set keepframes1 = `printf '%s\n' $keepframes | awk '{print $1+1}'`

    foreach fname (dwi.bvecs dwi.bvals)
      if (! -e $dwidir/$fname.full) then
        set cmd = (mv -f $dwidir/$fname $dwidir/$fname.full)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      endif

      foreach iframe ($keepframes1)
        set cmd = (sed -n ${iframe}p $dwidir/$fname.full)
        echo "$cmd >> $dwidir/$fname" |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          ($cmd >> $dwidir/$fname) >>& $LF
          if ($status) goto error_exit
        endif
      end
    end
  endif
endif

if ($doqa && $dobase) then
  echo "ERROR: Image quality assessment step not available for base template"
  goto error_exit
endif


#------------ Intra-subject registration ----------------------------------#

if ($dointra && ! $dobase && -e $fsdir/mri/brain.mgz) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Intra-subject registration `date`" |& tee -a $LF

  # Copy anatomical brain
  set cmd = mri_convert
  set cmd = ($cmd $fsdir/mri/brain.mgz)
  set cmd = ($cmd $dwidir/brain_anat_orig.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  # Change orientation to make FSL happy
  set cmd = orientLAS
  set cmd = ($cmd $dwidir/brain_anat_orig.nii.gz)
  set cmd = ($cmd $dwidir/brain_anat.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  # Calculate original anatomical to LAS anatomical
  set cmd = tkregister2
  set cmd = ($cmd --mov $dwidir/brain_anat_orig.nii.gz)
  set cmd = ($cmd --targ $dwidir/brain_anat.nii.gz)
  set cmd = ($cmd --regheader --noedit)
  set cmd = ($cmd --fslregout $xfmdir/anatorig2anat.mat)
  set cmd = ($cmd --reg $xfmdir/anat2anatorig.dat)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  set cmd = convert_xfm
  set cmd = ($cmd -omat $xfmdir/anat2anatorig.mat)
  set cmd = ($cmd -inverse $xfmdir/anatorig2anat.mat)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  if ($doregflt) then
    # Register low-b to anatomical using flirt
    set cmd = flirt
    set cmd = ($cmd -in $dwidir/lowb_brain.nii.gz)
    set cmd = ($cmd -ref $dwidir/brain_anat.nii.gz)
    set cmd = ($cmd -out $dwidir/lowb_brain_anat.flt.nii.gz)
    set cmd = ($cmd -omat $xfmdir/diff2anat.flt.mat)
    set cmd = ($cmd -cost corratio)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/anat2diff.flt.mat)
    set cmd = ($cmd -inverse $xfmdir/diff2anat.flt.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Calculate original (freesurfer) anatomical to low-b
    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/anatorig2diff.flt.mat)
    set cmd = ($cmd -concat $xfmdir/anat2diff.flt.mat)
    set cmd = ($cmd         $xfmdir/anatorig2anat.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/diff2anatorig.flt.mat)
    set cmd = ($cmd -inverse $xfmdir/anatorig2diff.flt.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif

  if ($doregbbr) then
    # Register low-b to anatomical using bbregister
    set cmd = bbregister
    set cmd = ($cmd --s $subj)
    set cmd = ($cmd --init-fsl --dti)
    set cmd = ($cmd --mov    $dwidir/dwi.nii.gz)
    set cmd = ($cmd --reg    $xfmdir/anatorig2diff.bbr.dat)
    set cmd = ($cmd --fslmat $xfmdir/diff2anatorig.bbr.mat)
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/anatorig2diff.bbr.mat)
    set cmd = ($cmd -inverse $xfmdir/diff2anatorig.bbr.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Calculate LAS anatomical to low-b
    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/anat2diff.bbr.mat)
    set cmd = ($cmd -concat $xfmdir/anatorig2diff.bbr.mat)
    set cmd = ($cmd         $xfmdir/anat2anatorig.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/diff2anat.bbr.mat)
    set cmd = ($cmd -inverse $xfmdir/anat2diff.bbr.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif
endif

if ($dointra && $dobase) then
  echo "ERROR: Intra-subject registration step not available for base template"
  goto error_exit
endif

#------------ Inter-subject registration ----------------------------------#

if ($dointer && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Inter-subject registration `date`" |& tee -a $LF

  if (-e $fsdir/mri/brain.mgz) then	# If individual T1 exists
    if ($doregmni) then
      # Register anatomical to MNI template
      set cmd = flirt
      set cmd = ($cmd -in $dwidir/brain_anat.nii.gz)
      set cmd = ($cmd -ref $mnitemp)
      set cmd = ($cmd -out $dwidir/brain_anat_mni.nii.gz)
      set cmd = ($cmd -omat $xfmdir/anat2mni.mat)
      set cmd = ($cmd -cost mutualinfo)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $fs_time $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set cmd = convert_xfm
      set cmd = ($cmd -omat $xfmdir/mni2anat.mat)
      set cmd = ($cmd -inverse $xfmdir/anat2mni.mat)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      # Calculate low-b to MNI template
      foreach reg (flt bbr)
        if (-e $xfmdir/diff2anat.$reg.mat) then
          set cmd = convert_xfm
          set cmd = ($cmd -omat $xfmdir/diff2mni.$reg.mat)
          set cmd = ($cmd -concat $xfmdir/anat2mni.mat)
          set cmd = ($cmd         $xfmdir/diff2anat.$reg.mat)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif

          set cmd = convert_xfm
          set cmd = ($cmd -omat $xfmdir/mni2diff.$reg.mat)
          set cmd = ($cmd -inverse $xfmdir/diff2mni.$reg.mat)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif
        endif
      end

      # Calculate original (freesurfer) anatomical to MNI template
      set cmd = convert_xfm
      set cmd = ($cmd -omat $xfmdir/anatorig2mni.mat)
      set cmd = ($cmd -concat $xfmdir/anat2mni.mat)
      set cmd = ($cmd         $xfmdir/anatorig2anat.mat)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      set cmd = convert_xfm
      set cmd = ($cmd -omat $xfmdir/mni2anatorig.mat)
      set cmd = ($cmd -inverse $xfmdir/anatorig2mni.mat)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    if ($doregcvs) then
      if ($subj == $cvstemp) then
        set cmd = (rm -f $xfmdir/cvs)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      else
        # Create morph of anatomical to CVS template if it doesn't exist
        if (-e $fsdir/cvs/el_reg_to$cvstemp.mgz) then
          set cmd = (ln -sfn $fsdir/cvs $xfmdir/cvs)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif
        else
          mkdir -p $fsdir/cvs/$cvstemp

          set cmd = (ln -sfn $fsdir/cvs/$cvstemp $xfmdir/cvs)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif
        endif

        set cvswarp = final_CVSmorph_to$cvstemp

        if (! -e $xfmdir/cvs/$cvswarp.m3z) then
          set oldcvswarp = combined_to${cvstemp}_elreg_afteraseg-norm

          if (-e $xfmdir/cvs/$oldcvswarp.m3z) then
            # If 2nd-generation CVS was run,
            # make symlink with 3rd-generation naming
            set cmd = (ln -s ./$oldcvswarp.m3z $xfmdir/cvs/$cvswarp.m3z)
            echo $cmd |& tee -a $LF |& tee -a $CF
            if ($RunIt) then
              $cmd |& tee -a $LF
              if ($status) goto error_exit
            endif
          else
            if (! -e $SUBJECTS_DIR/$cvstemp) then
              if (! -e $cvstempdir/$cvstemp) then
                echo "ERROR: Could not find CVS template $cvstempdir/$cvstemp"
                goto error_exit
              endif

              set cmd = (ln -s $cvstempdir/$cvstemp $SUBJECTS_DIR)
              echo $cmd |& tee -a $LF |& tee -a $CF
              if ($RunIt) then
                $cmd |& tee -a $LF
                if ($status) goto error_exit
              endif
            endif

            if (! -e $xfmdir/cvs/nlalign-afteraseg-norm.m3z) then
              # Register anatomical to CVS template
              set cmd = mri_cvs_register
              set cmd = ($cmd --mov $subj)
              set cmd = ($cmd --template $cvstemp)
              set cmd = ($cmd --outdir $xfmdir/cvs)
              set cmd = ($cmd --cleanall)
              echo $cmd |& tee -a $LF |& tee -a $CF
              if ($RunIt) then
                $fs_time $cmd |& tee -a $LF
                if ($status) goto error_exit
              endif
            else		# 1st-generation mri_cvs_register has been run
              if (! -e $xfmdir/cvs/$cvswarp.tm3d) then
                # Recreate full morph .tm3d from its components
                set cmd = createMorph
                set cmd = ($cmd --out $xfmdir/cvs/$cvswarp.tm3d)
                set cmd = ($cmd --template $SUBJECTS_DIR/$cvstemp/mri/norm.mgz)
                set cmd = ($cmd --subject $fsdir/mri/norm.mgz)
                set cmd = ($cmd --in gcam $xfmdir/cvs/nlalign-afteraseg-norm.m3z)
                set cmd = ($cmd      morph $xfmdir/cvs/el_reg_to$cvstemp.tm3d)
                echo $cmd |& tee -a $LF |& tee -a $CF
                if ($RunIt) then
                  $fs_time $cmd |& tee -a $LF
                  if ($status) goto error_exit
                endif
              endif

              # Convert .tm3d to .m3z
              set cmd = exportGcam
              set cmd = ($cmd --morph    $xfmdir/cvs/$cvswarp.tm3d)
              set cmd = ($cmd --fixed    $SUBJECTS_DIR/$cvstemp/mri/norm.mgz)
              set cmd = ($cmd --moving   $fsdir/mri/norm.mgz)
              set cmd = ($cmd --out_gcam $xfmdir/cvs/$cvswarp.m3z)
              if ($RunIt) then
                $fs_time $cmd |& tee -a $LF
                if ($status) goto error_exit
              endif
            endif
          endif
        endif
      endif
    endif
  else				# If individual T1 doesn't exist
    # Register low-b directly to MNI template
    set cmd = flirt
    set cmd = ($cmd -in $dwidir/lowb_brain.nii.gz)
    set cmd = ($cmd -ref $mnitemp)
    set cmd = ($cmd -out $dwidir/lowb_brain_mni.nii.gz)
    set cmd = ($cmd -omat $xfmdir/diff2mni.mat)
    set cmd = ($cmd -cost corratio)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $fs_time $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = convert_xfm
    set cmd = ($cmd -omat $xfmdir/mni2diff.mat)
    set cmd = ($cmd -inverse $xfmdir/diff2mni.mat)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif
endif

if ($dointer && $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Inter-subject registration (base template) `date`" |& tee -a $LF

  if ($doregmni) then
    # Affine registration from MNI template to base template
    # Hack: Using one time point for now!
    set xfmdir_t = $dtroot/$tplist[1]/dmri/xfms

    set cmd = cp
    set cmd = ($cmd $xfmdir_t/mni2anatorig.mat)
    set cmd = ($cmd $xfmdir_t/anatorig2mni.mat)
    set cmd = ($cmd $xfmdir)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  endif
endif

#------------ White-matter, cortex, and whole-brain masks -----------------#

if ($domasks && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Masks `date`" |& tee -a $LF

  set cvswarp = final_CVSmorph_to$cvstemp

  mkdir -p $labdir/diff
  if (-e $fsdir/mri/aparc+aseg.mgz) mkdir -p $labdir/anatorig $labdir/anat
  if ($doregmni && -e $xfmdir/anat2mni.mat) mkdir -p $labdir/mni
  if ($doregcvs) then
    if ($subj == $cvstemp) then
      if (-e $labdir/cvs && ! -l $labdir/cvs) rm -rf $labdir/cvs
      ln -sfn $labdir/anatorig $labdir/cvs
    else
      if (-l $labdir/cvs) rm -f $labdir/cvs
      if (-e $xfmdir/cvs/$cvswarp.m3z) mkdir -p $labdir/cvs
    endif
  endif

  if (! -e $fsdir/mri/aparc+aseg.mgz) then
    echo "WARN: Could not find $fsdir/mri/aparc+aseg.mgz"
    echo "WARN: You will not be able to complete TRACULA processing without it"
  else
    #
    # Extract all necessary files from FreeSurfer segmentation
    # (cross-sectional or longitudinal)
    #

    set wmlist = ( Left-Cerebral-White-Matter \
                   Left-Cerebellum-White-Matter \
                   Right-Cerebral-White-Matter \
                   Right-Cerebellum-White-Matter \
                   WM-hypointensities \
                   Left-VentralDC \
                   Right-VentralDC \
                   Brain-Stem )

    set ventlist = ( Left-Lateral-Ventricle \
                     Right-Lateral-Ventricle )

    set fslut = $FREESURFER_HOME/FreeSurferColorLUT.txt

    # Make mask including cerebral WM, cerebellar WM, and WM hypointensities
    set cmd = mri_binarize
    set cmd = ($cmd --i $fsdir/mri/aparc+aseg.mgz)
    foreach label ($wmlist[1-5])
      set id = `grep -i " ${label}[ \t]" $fslut`
      set id = $id[1]
      set cmd = ($cmd --match $id)
    end
    set cmd = ($cmd --o $labdir/anatorig/White-Matter.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # As above, plus ventral DC and brainstem
    set cmd = mri_binarize
    set cmd = ($cmd --i $fsdir/mri/aparc+aseg.mgz)
    foreach label ($wmlist)
      set id = `grep -i " ${label}[ \t]" $fslut`
      set id = $id[1]
      set cmd = ($cmd --match $id)
    end
    set cmd = ($cmd --o $labdir/anatorig/White-Matter++.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Make mask excluding lateral ventricles
    set cmd = mri_binarize
    set cmd = ($cmd --i $fsdir/mri/aparc+aseg.mgz)
    foreach label ($ventlist)
      set id = `grep -i " ${label}[ \t]" $fslut`
      set id = $id[1]
      set cmd = ($cmd --match $id)
    end
    set cmd = ($cmd --binval 0 --binvalnot 1)
    set cmd = ($cmd --o $labdir/anatorig/notventricles.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Map cortical parcellation to volume, growing 2mm into the WM
    set gmgrow = 2

    set cmd = mri_aparc2aseg
    set cmd = ($cmd --s $subj)
    set cmd = ($cmd --annot aparc)
    set cmd = ($cmd --wmparc-dmax $gmgrow)
    set cmd = ($cmd --labelwm --hypo-as-wm)
    set cmd = ($cmd --o $labdir/anatorig/aparc+aseg+${gmgrow}mm.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Make mask of cortex
    set cmd = mri_binarize
    set cmd = ($cmd --i $labdir/anatorig/aparc+aseg+${gmgrow}mm.nii.gz)
    set cmd = ($cmd --min 1000 --max 2999)
    set cmd = ($cmd --o $labdir/anatorig/cortex.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Make mask of grown cortex
    set cmd = mri_binarize
    set cmd = ($cmd --i $labdir/anatorig/aparc+aseg+${gmgrow}mm.nii.gz)
    set cmd = ($cmd --min 1000 --max 4999)
    set cmd = ($cmd --o $labdir/anatorig/cortex+${gmgrow}mm.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Make mask of grown cortex plus brainstem
    set id = `grep -i " Brain-Stem[ \t]" $fslut`
    set id = $id[1]

    set cmd = mri_binarize
    set cmd = ($cmd --i $fsdir/mri/aparc+aseg.mgz)
    set cmd = ($cmd --match $id)
    set cmd = ($cmd --o $labdir/anatorig/Brain-Stem.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    set cmd = fslmaths
    set cmd = ($cmd      $labdir/anatorig/cortex+${gmgrow}mm.nii.gz)
    set cmd = ($cmd -add $labdir/anatorig/Brain-Stem.nii.gz)
    set cmd = ($cmd      $labdir/anatorig/cortex+${gmgrow}mm+bs.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Copy T1 brain mask
    set cmd = mri_convert
    set cmd = ($cmd $fsdir/mri/brainmask.mgz)
    set cmd = ($cmd $labdir/anatorig/anat_brain_mask.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Exclude ventricles from brain mask
    set cmd = fslmaths
    set cmd = ($cmd      $labdir/anatorig/anat_brain_mask.nii.gz)
    set cmd = ($cmd -mul $labdir/anatorig/notventricles.nii.gz)
    set cmd = ($cmd      $labdir/anatorig/anat_brain_mask-vent.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Copy T1 segmentation
    set cmd = mri_convert
    set cmd = ($cmd $fsdir/mri/aparc+aseg.mgz)
    set cmd = ($cmd $labdir/anatorig/aparc+aseg.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    # Dilate segmentation to make brain mask
    set cmd = fslmaths
    set cmd = ($cmd $labdir/anatorig/aparc+aseg.nii.gz)
    set cmd = ($cmd -dilM -bin)
    set cmd = ($cmd $labdir/anatorig/aparc+aseg_mask.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif

    foreach label ( White-Matter White-Matter++ notventricles \
                    cortex cortex+${gmgrow}mm cortex+${gmgrow}mm+bs \
                    aparc+aseg aparc+aseg+${gmgrow}mm aparc+aseg_mask \
                    anat_brain_mask anat_brain_mask-vent )
      # Change orientation to make FSL happy
      set cmd = orientLAS
      set cmd = ($cmd $labdir/anatorig/$label.nii.gz)
      set cmd = ($cmd $labdir/anat/$label.nii.gz)
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      # Map label to diffusion space
      foreach reg (flt bbr)
        if (-e $xfmdir/anat2diff.$reg.mat) then
          set cmd = flirt
          set cmd = ($cmd -in $labdir/anat/$label.nii.gz)
          set cmd = ($cmd -ref $dwidir/lowb.nii.gz)
          set cmd = ($cmd -out $labdir/diff/$label.$reg.nii.gz)
          set cmd = ($cmd -applyxfm -init $xfmdir/anat2diff.$reg.mat)
          set cmd = ($cmd -interp nearestneighbour)		# Binary masks!
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif
        endif
      end

      # Map label to MNI space
      if ($doregmni && -e $xfmdir/anat2mni.mat) then
        set cmd = flirt
        set cmd = ($cmd -in $labdir/anat/$label.nii.gz)
        set cmd = ($cmd -ref $mnitemp)
        set cmd = ($cmd -out $labdir/mni/$label.nii.gz)
        set cmd = ($cmd -applyxfm -init $xfmdir/anat2mni.mat)
        set cmd = ($cmd -interp nearestneighbour)		# Binary masks!
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      endif

      # Map label to CVS space
      if ($doregcvs && -e $xfmdir/cvs/$cvswarp.m3z) then
        set cmd = mri_vol2vol
        set cmd = ($cmd --mov  $labdir/anatorig/$label.nii.gz)
        set cmd = ($cmd --targ $SUBJECTS_DIR/$cvstemp/mri/norm.mgz)
        set cmd = ($cmd --o    $labdir/cvs/$label.nii.gz)
        set cmd = ($cmd --m3z  $xfmdir/cvs/$cvswarp.m3z)
        set cmd = ($cmd --noDefM3zPath)
        set cmd = ($cmd --interp nearest)			# Binary masks!
        set cmd = ($cmd --no-save-reg)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      endif
    end

    # Calculate SNR of DWIs in WM mask
    set cmd = fslstats
    set cmd = ($cmd -t $dwidir/dwi.nii.gz)
    if ($doregbbr && -e $labdir/diff/White-Matter++.bbr.nii.gz) then
      set cmd = ($cmd -k $labdir/diff/White-Matter++.bbr.nii.gz)
    else
      set cmd = ($cmd -k $labdir/diff/White-Matter++.flt.nii.gz)
    endif
    set cmd = ($cmd -m -s)
    echo "$cmd | awk '{print "'$1/$2'"}' > $dwidir/dwi_snr.txt" \
      |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      ($cmd | awk '{print $1/$2}' > $dwidir/dwi_snr.txt) >>& $LF
    endif
  endif

  foreach reg (flt bbr)
    if ($doregmni && -e $xfmdir/diff2mni.$reg.mat) then
      # Map diffusion brain mask to MNI space
      set cmd = flirt
      set cmd = ($cmd -in $labdir/diff/lowb_brain_mask.nii.gz)
      set cmd = ($cmd -ref $mnitemp)
      set cmd = ($cmd -out $labdir/mni/lowb_brain_mask.$reg.nii.gz)
      set cmd = ($cmd -applyxfm -init $xfmdir/diff2mni.$reg.mat)
      set cmd = ($cmd -interp nearestneighbour)			# Binary masks!
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif
    endif

    if (-e $xfmdir/diff2anatorig.$reg.mat) then
      # Map diffusion brain mask to individual anatomical space
      set cmd = flirt
      set cmd = ($cmd -in  $labdir/diff/lowb_brain_mask.nii.gz)
      set cmd = ($cmd -ref $dwidir/brain_anat_orig.nii.gz)
      set cmd = ($cmd -out $labdir/anatorig/lowb_brain_mask.$reg.nii.gz)
      set cmd = ($cmd -applyxfm -init $xfmdir/diff2anatorig.$reg.mat)
      set cmd = ($cmd -interp nearestneighbour)			# Binary masks!
      echo $cmd |& tee -a $LF |& tee -a $CF
      if ($RunIt) then
        $cmd |& tee -a $LF
        if ($status) goto error_exit
      endif

      if ($doregcvs && -e $xfmdir/cvs/$cvswarp.m3z) then
        # Map diffusion brain mask to CVS space
        set cmd = mri_vol2vol
        set cmd = ($cmd --mov  $labdir/anatorig/lowb_brain_mask.$reg.nii.gz)
        set cmd = ($cmd --targ $SUBJECTS_DIR/$cvstemp/mri/norm.mgz)
        set cmd = ($cmd --o    $labdir/cvs/lowb_brain_mask.$reg.nii.gz)
        set cmd = ($cmd --m3z  $xfmdir/cvs/$cvswarp.m3z)
        set cmd = ($cmd --noDefM3zPath)
        set cmd = ($cmd --interp nearest)			# Binary masks!
        set cmd = ($cmd --no-save-reg)
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      endif
    endif
  end

  # Create symbolic link to brain mask with the name that bedpostx expects
  set bedmask = $labdir/diff/lowb_brain_mask.nii.gz

  if ($usemaskanat) then
    if ($doregbbr && -e $labdir/diff/aparc+aseg_mask.bbr.nii.gz) then
      set bedmask = $labdir/diff/aparc+aseg_mask.bbr.nii.gz
    else if (-e $labdir/diff/aparc+aseg_mask.flt.nii.gz) then
      set bedmask = $labdir/diff/aparc+aseg_mask.flt.nii.gz
    endif
  endif

  set cmd = (ln -sf $bedmask $dwidir/nodif_brain_mask.nii.gz)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif
endif

if ($domasks && $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Masks (base template) `date`" |& tee -a $LF

  mkdir -p $labdir/anatorig

  # Compute intersection of masks from all time points
  set flist = (aparc+aseg_mask)
  if ($doregflt) set flist = ($flist lowb_brain_mask.flt)
  if ($doregbbr) set flist = ($flist lowb_brain_mask.bbr)

  foreach fname ($flist)
    set inlist = `printf "$dtroot/%s/dlabel/anatorig/$fname.nii.gz " $tplist`

    set cmd = mri_concat
    set cmd = ($cmd --i $inlist)
    set cmd = ($cmd --min)
    set cmd = ($cmd --o $labdir/anatorig/$fname.nii.gz)
    echo $cmd |& tee -a $LF |& tee -a $CF
    if ($RunIt) then
      $cmd |& tee -a $LF
      if ($status) goto error_exit
    endif
  end
endif

#------------ Tensor fit --------------------------------------------------#

if ($dotensor && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Tensor fit `date`" |& tee -a $LF

  set brainmask = $labdir/diff/lowb_brain_mask.nii.gz

  if ($usemaskanat) then
    if ($doregbbr && -e $labdir/diff/aparc+aseg_mask.bbr.nii.gz) then
      set brainmask = $labdir/diff/aparc+aseg_mask.bbr.nii.gz
    else if (-e $labdir/diff/aparc+aseg_mask.flt.nii.gz) then
      set brainmask = $labdir/diff/aparc+aseg_mask.flt.nii.gz
    endif
  endif

  # LS tensor estimation
  set cmd = dtifit
  set cmd = ($cmd -k $dwidir/dwi.nii.gz)
  set cmd = ($cmd -m $brainmask)
  set cmd = ($cmd -r $dwidir/bvecs)
  set cmd = ($cmd -b $dwidir/bvals)
  set cmd = ($cmd -o $dwidir/dtifit)
  echo $cmd |& tee -a $LF |& tee -a $CF
  if ($RunIt) then
    $fs_time $cmd |& tee -a $LF
    if ($status) goto error_exit
  endif

  # Check for scalar outputs of tensor fit
  set maplist = ()
  foreach fname ( `cd $dwidir; ls dtifit_*` )
    if (`mri_info --nframes $dwidir/$fname` == 1) then
      set maplist = ($maplist `echo $fname | sed 's/.nii.gz//'`)
    endif
  end

  # Map scalar outputs of tensor fit to MNI template
  if ($doregmni) then
    mkdir -p $dwidir/mni

    foreach reg (flt bbr)
      if (-e $xfmdir/diff2mni.$reg.mat) then
        foreach fname ($maplist)
          set cmd = flirt
          set cmd = ($cmd -in $dwidir/$fname.nii.gz)
          set cmd = ($cmd -ref $mnitemp)
          set cmd = ($cmd -out $dwidir/mni/$fname.$reg.nii.gz)
          set cmd = ($cmd -applyxfm -init $xfmdir/diff2mni.$reg.mat)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif
        end
      endif
    end
  endif

  # Map scalar outputs of tensor fit to CVS template
  set cvswarp = final_CVSmorph_to$cvstemp

  if ($doregcvs && -e $xfmdir/cvs/$cvswarp.m3z) then
    mkdir -p $dwidir/anatorig

    if ($subj == $cvstemp) then
      if (-e $dwidir/cvs && ! -l $dwidir/cvs) rm -rf $dwidir/cvs
      ln -sfn $dwidir/anatorig $dwidir/cvs
    else
      if (-l $dwidir/cvs) rm -f $dwidir/cvs
      if (-e $xfmdir/cvs/$cvswarp.m3z) mkdir -p $dwidir/cvs
    endif

    foreach reg (flt bbr)
      foreach fname ($maplist)
        if (-e $xfmdir/diff2anatorig.$reg.mat) then
          set cmd = flirt
          set cmd = ($cmd -in  $dwidir/$fname.nii.gz)
          set cmd = ($cmd -ref $dwidir/brain_anat_orig.nii.gz)
          set cmd = ($cmd -out $dwidir/anatorig/$fname.$reg.nii.gz)
          set cmd = ($cmd -applyxfm -init $xfmdir/diff2anatorig.$reg.mat)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) goto error_exit
          endif

          if (-e $xfmdir/cvs/$cvswarp.m3z) then
            set cmd = mri_vol2vol
            set cmd = ($cmd --mov  $dwidir/anatorig/$fname.$reg.nii.gz)
            set cmd = ($cmd --targ $SUBJECTS_DIR/$cvstemp/mri/norm.mgz)
            set cmd = ($cmd --o    $dwidir/cvs/$fname.$reg.nii.gz)
            set cmd = ($cmd --m3z  $xfmdir/cvs/$cvswarp.m3z)
            set cmd = ($cmd --noDefM3zPath)
            set cmd = ($cmd --interp trilin)
            set cmd = ($cmd --no-save-reg)
            echo $cmd |& tee -a $LF |& tee -a $CF
            if ($RunIt) then
              $cmd |& tee -a $LF
              if ($status) goto error_exit
            endif
          endif
        endif
      end
    end
  endif
endif

if ($dotensor && $dobase) then
  echo "ERROR: Tensor-fit step not available for base template"
  goto error_exit
endif

#------------ Combine training data ---------------------------------------#

if ($dopriors && ! $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Priors `date`" |& tee -a $LF

  set cvswarp = final_CVSmorph_to$cvstemp

  set xspacelist = ()
  if ($doregmni) set xspacelist = ($xspacelist mni)
  if ($doregcvs) set xspacelist = ($xspacelist cvs)

  set reglist = ()
  if ($doregflt) set reglist = ($reglist flt)
  if ($doregbbr) set reglist = ($reglist bbr)

  foreach ntrain ($ntrainlist)
    # Use a subset of the training subjects
    set slistfile = /tmp/subj$ntrain.$subj.$$.txt
    echo "$trainsubjlist[1-$ntrain]" > $slistfile

    foreach xspace ($xspacelist)
      foreach reg ($reglist)
        set avgmode = $avgname${ntrain}_${xspace}_$reg

        set outdir = $labdir/$xspace
        set outlist = `printf "%s_$avgmode " $pathlist`

        set trklist = `printf "dlabel/$xspace/%s.$reg.trk " $pathlist`

        set roilist = ()
        set lablist = ()
        foreach pathname ($pathlist)
          set roilist = ($roilist \
                         dlabel/$xspace/${pathname}_roi1.$reg.nii.gz \
                         dlabel/$xspace/${pathname}_roi2.$reg.nii.gz)

          if ($pathname =~ *cst*) then
            set lablist = ($lablist 16)		# Add brainstem
          else if ($pathname =~ lh.atr*) then
            set lablist = ($lablist 10)		# Add left thalamus proper
          else if ($pathname =~ rh.atr*) then
            set lablist = ($lablist 49)		# Add right thalamus proper
          else
            set lablist = ($lablist 0)		# Add nothing
          endif
        end

        set brainmask = $labdir/$xspace/lowb_brain_mask.$reg.nii.gz

        if ($usemaskanat && -e $labdir/$xspace/aparc+aseg_mask.nii.gz) then
          set brainmask = $labdir/$xspace/aparc+aseg_mask.nii.gz
        endif

        if ($reinit) then	# Exclude previous spline initialization
          foreach outbase ($outlist)
            set oldinit = $outdir/${outbase}_cpts_all.txt

            if (-e $oldinit) then
              set excfile = $outdir/${outbase}_cpts_all.bad.txt
              echo exclude >> $excfile
              cat $oldinit >> $excfile
            endif
          end
        endif

        # Compute priors, end ROIs, and initial control points from training set
        set cmd = $trcdir/dmri_train
        set cmd = ($cmd --outdir $outdir)
        set cmd = ($cmd --out    $outlist)
        set cmd = ($cmd --slist  $slistfile)
        set cmd = ($cmd --trk    $trklist)
        set cmd = ($cmd --seg    dlabel/$xspace/aparc+aseg.nii.gz)
        set cmd = ($cmd --cmask  dlabel/$xspace/cortex+2mm.nii.gz)
        set cmd = ($cmd --lmask  $lablist)
        set cmd = ($cmd --rois   $roilist)
        set cmd = ($cmd --bmask  $brainmask)
        set cmd = ($cmd --fa     $dwidir/dtifit_FA.nii.gz)
        set cmd = ($cmd --cptdir $labdir/diff)
        if ($xspace == mni) then
          set cmd = ($cmd --reg   $xfmdir/mni2diff.$reg.mat)
        else if ($xspace == cvs) then
          set cmd = ($cmd --regnl $xfmdir/cvs/$cvswarp.m3z)
          set cmd = ($cmd --reg   $xfmdir/anatorig2diff.$reg.mat)
          set cmd = ($cmd --refnl $dwidir/brain_anat_orig.nii.gz)
        endif
        set cmd = ($cmd --ncpts $ncpts)
        if ($reinit) then
          set cmd = ($cmd --xstr)
        endif
        if ($usetrunc) then
          set cmd = ($cmd --trunc)
        endif
        if ($debug) then
          set cmd = ($cmd --debug)
        endif
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      end
    end
  end
endif

if ($dopriors && $dobase) then
  echo "#-------------------------------------" |& tee -a $LF
  echo "#@# Priors (base template) `date`" |& tee -a $LF

  set cvswarp = final_CVSmorph_to$cvstemp

  set xspacelist = ()
  if ($doregmni) set xspacelist = ($xspacelist mni)
  if ($doregcvs) set xspacelist = ($xspacelist cvs)

  set reglist = ()
  if ($doregflt) set reglist = ($reglist flt)
  if ($doregbbr) set reglist = ($reglist bbr)

  foreach ntrain ($ntrainlist)
    # Use a subset of the training subjects
    set slistfile = /tmp/subj$ntrain.$subj.$$.txt
    echo "$trainsubjlist[1-$ntrain]" > $slistfile

    foreach xspace ($xspacelist)
      mkdir -p $labdir/$xspace

      foreach reg ($reglist)
        set avgmode = $avgname${ntrain}_${xspace}_$reg

        set outdir = $labdir/$xspace
        set outlist = `printf "%s_$avgmode " $pathlist`

        set trklist = `printf "dlabel/$xspace/%s.$reg.trk " $pathlist`

        set roilist = ()
        set lablist = ()
        foreach pathname ($pathlist)
          set roilist = ($roilist \
                         dlabel/$xspace/${pathname}_roi1.$reg.nii.gz \
                         dlabel/$xspace/${pathname}_roi2.$reg.nii.gz)

          if ($pathname =~ *cst*) then
            set lablist = ($lablist 16)		# Add brainstem
          else if ($pathname =~ lh.atr*) then
            set lablist = ($lablist 10)		# Add left thalamus proper
          else if ($pathname =~ rh.atr*) then
            set lablist = ($lablist 49)		# Add right thalamus proper
          else
            set lablist = ($lablist 0)		# Add nothing
          endif
        end

        if ($usemaskanat) then
          set brainmask = aparc+aseg_mask.nii.gz
        else
          set brainmask = lowb_brain_mask.$reg.nii.gz
        endif

        set bmasklist = \
          `printf "$dtroot/%s/dlabel/$xspace/$brainmask " $tplist`

        set falist = \
          `printf "$dtroot/%s/dmri/dtifit_FA.nii.gz " $tplist`

        set basereglist = \
          `printf "$dtroot/%s/dmri/xfms/anatorig2diff.$reg.mat " $tplist`

        if ($reinit) then	# Exclude previous spline initialization
          foreach outbase ($outlist)
            set oldinit = $outdir/${outbase}_cpts_all.txt

            if (-e $oldinit) then
              set excfile = $outdir/${outbase}_cpts_all.bad.txt
              echo exclude >> $excfile
              cat $oldinit >> $excfile
            endif
          end
        endif

        # Compute priors, end ROIs, and initial control points from training set
        set cmd = $trcdir/dmri_train
        set cmd = ($cmd --outdir  $outdir)
        set cmd = ($cmd --out     $outlist)
        set cmd = ($cmd --slist   $slistfile)
        set cmd = ($cmd --trk     $trklist)
        set cmd = ($cmd --seg     dlabel/$xspace/aparc+aseg.nii.gz)
        set cmd = ($cmd --cmask   dlabel/$xspace/cortex+2mm.nii.gz)
        set cmd = ($cmd --lmask   $lablist)
        set cmd = ($cmd --rois    $roilist)
        set cmd = ($cmd --bmask   $bmasklist)
        set cmd = ($cmd --fa      $falist)
        set cmd = ($cmd --cptdir  $labdir/anatorig)
        if ($xspace == mni) then
          set cmd = ($cmd --reg   $xfmdir/mni2anatorig.mat)
        else if ($xspace == cvs) then
          # Hack: Using one time point for now!
          set dwidir_t = $dtroot/$tplist[1]/dmri
          set xfmdir_t = $dwidir_t/xfms

          set cmd = ($cmd --regnl $xfmdir_t/cvs/$cvswarp.m3z)
          set cmd = ($cmd --refnl $dwidir_t/brain_anat_orig.nii.gz)
        endif
        set cmd = ($cmd --basereg $basereglist)
        set cmd = ($cmd --baseref $labdir/anatorig/aparc+aseg_mask.nii.gz)
        set cmd = ($cmd --ncpts   $ncpts)
        if ($reinit) then
          set cmd = ($cmd --xstr)
        endif
        if ($usetrunc) then
          set cmd = ($cmd --trunc)
        endif
        if ($debug) then
          set cmd = ($cmd --debug)
        endif
        echo $cmd |& tee -a $LF |& tee -a $CF
        if ($RunIt) then
          $fs_time $cmd |& tee -a $LF
          if ($status) goto error_exit
        endif
      end
    end
  end
endif

# Remove the error file
if ($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile

# Create the done file
echo "------------------------------" > $DoneFile
echo "SUBJECT $subj" >> $DoneFile
echo "DATE `date`"     >> $DoneFile
echo "USER `whoami`"      >> $DoneFile
echo "HOST `hostname`" >> $DoneFile
echo "PROCESSOR `uname -m`" >> $DoneFile
echo "OS `uname -s`"       >> $DoneFile
uname -a         >> $DoneFile
echo $VERSION    >> $DoneFile
echo $0          >> $DoneFile

echo "#-------------------------------------" |& tee -a $LF
echo "$ProgName finished without error at `date`" |& tee -a $LF

exit 0
#############------------------------------------#######################
##################>>>>>>>>>>>>>.<<<<<<<<<<<<<<<<<#######################
#############------------------------------------#######################

############--------------##################
error_exit:
  uname -a | tee -a $LF
  echo "" |& tee -a $LF
  echo "$ProgName exited with ERRORS at `date`" |& tee -a $LF
  echo "" |& tee -a $LF

  # Remove IsRunningFile
  if($DoIsRunning && $#IsRunningFile) rm -f $IsRunningFile

  # Create an error file with date, cmd, etc of error
  if ($?ErrorFile) then
    echo "------------------------------" > $ErrorFile
    echo "SUBJECT $subj" >> $ErrorFile
    echo "DATE `date`"     >> $ErrorFile
    echo "USER `whoami`"      >> $ErrorFile
    echo "HOST `hostname`" >> $ErrorFile
    echo "PROCESSOR `uname -m`" >> $ErrorFile
    echo "OS `uname -s`"       >> $ErrorFile
    uname -a         >> $ErrorFile
    echo $VERSION    >> $ErrorFile
    echo $0          >> $ErrorFile
    echo "PWD `pwd`" >> $ErrorFile
    echo "CMD $cmd"  >> $ErrorFile
  endif

  # Finally exit
  exit 1

############--------------##################
parse_args:
set cmdline = ($argv)

while( $#argv != 0 )
  set flag = $argv[1]; shift;

  if ("$flag" == ";") break;

  switch($flag)
    case "-c":
      if ( $#argv < 1) goto arg1err;
      set rcfile = "$argv[1]"; shift;
      if (! -e "$rcfile") then
        echo "ERROR: cannot find $rcfile"
        goto error_exit
      endif
      if (! -r "$rcfile") then
        echo "ERROR: $rcfile exists but is not readable"
        goto error_exit
      endif
      breaksw

    case "-time":
      set DoTime = 1
      breaksw

    case "-notime":
      set DoTime = 0
      breaksw

    case "-log":
      if ( $#argv < 1) goto arg1err;
      set LF = $argv[1]; shift;
      breaksw

    case "-nolog":
      set LF = /dev/null
      breaksw

    case "-cmd":
      if ( $#argv < 1) goto arg1err;
      set CF = $argv[1]; shift;
      breaksw

    case "-nocmd":
      set CF = /dev/null
      breaksw

    case "-no-isrunning":
      set DoIsRunning = 0
      breaksw

    case "-umask":
      if ( $#argv < 1) goto arg1err;
      umask $1; shift;
      breaksw

    case "-grp":
      if ( $#argv < 1) goto arg1err;
      set grp = $argv[1];
      set curgrp = `id -gn`;
      if($grp != $curgrp) then
        echo "ERROR: current group $curgrp and specified group $grp differ"
        goto error_exit;
      endif
      breaksw

    case "-allowcoredump":
      limit coredumpsize unlimited
      breaksw

    case "-debug":
      set debug = 1
      breaksw

    case "-dontrun":
      set RunIt = 0
      breaksw

    case "-onlyversions":
      set DoVersionsOnly = 1
      breaksw

    default:
      echo "ERROR: flag $flag unrecognized"
      echo $cmdline
      goto error_exit
      breaksw
  endsw
end

goto parse_args_return;

############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  goto error_exit

############--------------##################
check_params:
  if (! $#rcfile) then
    echo "ERROR: a configuration (dmrirc) file must be specified"
    goto error_exit
  endif

  if (! $#LF) set LF = `dirname $rcfile`/trac-all.log
  if (! $#CF) set CF = `dirname $rcfile`/trac-all.cmd

goto check_params_return;

############--------------##################
usage_exit:
  echo ""
  echo "USAGE: $ProgName"
  echo ""
  echo "Required arguments:"
  echo "  -c <file>      : dmrirc file (see dmrirc.example)"
  echo ""
  echo "Other arguments:"
  echo "  -log <file>    : default is trac-all.log in the same dir as dmrirc"
  echo "  -nolog         : do not save a log file"
  echo "  -cmd <file>    : default is trac-all.cmd in the same dir as dmrirc"
  echo "  -nocmd         : do not save a cmd file"
  echo "  -no-isrunning  : do not check whether this subject is currently being processed"
  echo "  -umask umask   : set unix file permission mask (default 002)"
  echo "  -grp groupid   : check that current group is alpha groupid "
  echo "  -allowcoredump : set coredump limit to unlimited"
  echo "  -debug         : generate much more output"
  echo "  -dontrun       : do everything but execute each command"
  echo "  -version       : print version of this script and exit"
  echo "  -help          : print full contents of help"
  echo ""

  if(! $PrintHelp) exit 1

  echo $VERSION
  echo ""

  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0;if($1 == "BEGINHELP") prt=1}'

  exit 1

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Tractography pre-processing for a single subject.

This script is called by trac-all. Trac-all makes sure that a proper
configuration file is written locally (scripts/dmrirc.local) and passed
as an argument to this script.

SEE ALSO: trac-all, dmrirc.example

